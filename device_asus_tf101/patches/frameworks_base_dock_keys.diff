diff --git a/core/java/org/teameos/jellybean/settings/EOSConstants.java b/core/java/org/teameos/jellybean/settings/EOSConstants.java
new file mode 100644
index 0000000..efdd759
--- /dev/null
+++ b/core/java/org/teameos/jellybean/settings/EOSConstants.java
@@ -0,0 +1,303 @@
+
+package org.teameos.jellybean.settings;
+
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+public final class EOSConstants {
+    /* EOS SETTINGS STRINGS */
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_BATTERY_ICON_VISIBLE = "eos_systemui_battery_icon_visible";
+
+    /**
+     * @hide
+     */
+    public static final int SYSTEMUI_BATTERY_ICON_VISIBLE_DEF = 1;
+
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_BATTERY_TEXT_VISIBLE = "eos_systemui_battery_text_visible";
+
+    /**
+     * @hide
+     */
+    public static final int SYSTEMUI_BATTERY_TEXT_VISIBLE_DEF = 1;
+
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_BATTERY_PERCENT_VISIBLE = "eos_systemui_battery_percent_visible";
+
+    /**
+     * @hide
+     */
+    public static final int SYSTEMUI_BATTERY_PERCENT_VISIBLE_DEF = 1;
+
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_BATTERY_PERCENT_TAG = "eos_systemui_battery_percent_tag";
+
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_BATTERY_TEXT_COLOR = "eos_systemui_battery_text_color";
+
+    /**
+     * @hide
+     */
+    public static final int SYSTEMUI_BATTERY_TEXT_COLOR_DEF = -1;
+
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_CLOCK_VISIBLE = "eos_systemui_clock_visible";
+
+    /**
+     * @hide
+     */
+    public static final int SYSTEMUI_CLOCK_VISIBLE_DEF = 1;
+
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_CLOCK_COLOR = "eos_systemui_clock_color";
+
+    /**
+     * @hide
+     */
+    public static final int SYSTEMUI_CLOCK_COLOR_DEF = -1;
+
+    /**
+     * @hide
+     */    
+    public static final String SYSTEMUI_CLOCK_AMPM = "eos_systemui_clock_ampm";
+
+    /**
+     * @hide
+     */
+    public static final int SYSTEMUI_CLOCK_AMPM_DEF = 2;
+
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_SETTINGS_ENABLED = "eos_systemui_settings_enabled";
+
+    /**
+     * @hide
+     */
+    public static final int SYSTEMUI_SETTINGS_ENABLED_DEF = 0;
+
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_SETTINGS_ENABLED_CONTROLS = "eos_systemui_settings_enabled_controls";
+
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_SETTINGS_PHONE_TOP = "eos_systemui_settings_phone_top";
+
+    /**
+     * @hide
+     */
+    public static final int SYSTEMUI_SETTINGS_PHONE_TOP_DEF = 0;
+
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_SETTINGS_PHONE_BOTTOM = "eos_systemui_settings_phone_bottom";
+
+    /**
+     * @hide
+     */
+    public static final int SYSTEMUI_SETTINGS_PHONE_BOTTOM_DEF = 0;
+
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_SETTINGS_AIRPLANE = "eos_systemui_settings_airplane";
+
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_SETTINGS_AUTO_ROTATE = "eos_systemui_settings_autorotate";
+
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_SETTINGS_BLUETOOTH = "eos_systemui_settings_bluetooth";
+
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_SETTINGS_GPS = "eos_systemui_settings_gps";
+
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_SETTINGS_NOTIFICATIONS = "eos_systemui_settings_notifications";
+
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_SETTINGS_SILENT = "eos_systemui_settings_silent";
+
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_SETTINGS_TORCH = "eos_systemui_settings_torch";
+
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_SETTINGS_WIFI = "eos_systemui_settings_wifi";
+
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_SETTINGS_MOBILEDATA = "eos_systemui_settings_mobiledata";
+
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_SETTINGS_WIFITETHER = "eos_systemui_settings_wifitether";
+
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_SETTINGS_USBTETHER = "eos_systemui_settings_usbtether";
+
+    /**
+     * @hide
+     */
+    public static final String[] SYSTEMUI_SETTINGS_DEFAULTS = {
+            SYSTEMUI_SETTINGS_WIFI,
+            SYSTEMUI_SETTINGS_BLUETOOTH,
+            SYSTEMUI_SETTINGS_GPS,
+            SYSTEMUI_SETTINGS_AUTO_ROTATE,
+            SYSTEMUI_SETTINGS_SILENT
+    };
+
+    /**
+     * @hide
+     */
+    public static final Map<String, Boolean> getEosSystemUISettingsMap() {
+        LinkedHashMap<String, Boolean> map = new LinkedHashMap<String, Boolean>();
+        map.put(SYSTEMUI_SETTINGS_AIRPLANE, false);
+        map.put(SYSTEMUI_SETTINGS_AUTO_ROTATE, true);
+        map.put(SYSTEMUI_SETTINGS_BLUETOOTH, true);
+        map.put(SYSTEMUI_SETTINGS_GPS, true);
+        map.put(SYSTEMUI_SETTINGS_NOTIFICATIONS, false);
+        map.put(SYSTEMUI_SETTINGS_SILENT, true);
+        map.put(SYSTEMUI_SETTINGS_TORCH, false);
+        map.put(SYSTEMUI_SETTINGS_WIFI, true);
+        map.put(SYSTEMUI_SETTINGS_MOBILEDATA, false);
+        map.put(SYSTEMUI_SETTINGS_WIFITETHER, false);
+        map.put(SYSTEMUI_SETTINGS_USBTETHER, false);
+
+        return map;
+    }
+
+    /***
+     * EOS Intent constants
+     */
+
+    /**
+     * Broadcast Action: Request to turn Eos Torch application off
+     * 
+     * @hide
+     */
+    public static final String ACTION_TORCH_OFF = "android.intent.action.TORCH_OFF";
+
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_SETTINGS_STANDARD_WIFI = "eos_systemui_settings_standard_wifi";
+    /**
+     * @hide
+     */
+    public static final int SYSTEMUI_SETTINGS_STANDARD_WIFI_DEF = 1;
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_SETTINGS_STANDARD_AIRPLANE = "eos_systemui_settings_standard_airplane";
+    /**
+     * @hide
+     */
+    public static final int SYSTEMUI_SETTINGS_STANDARD_AIRPLANE_DEF = 1;
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_SETTINGS_STANDARD_ROTATION = "eos_systemui_settings_standard_rotation";
+    /**
+     * @hide
+     */
+    public static final int SYSTEMUI_SETTINGS_STANDARD_ROTATION_DEF = 1;
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_SETTINGS_STANDARD_VOLUME = "eos_systemui_settings_standard_volume";
+    /**
+     * @hide
+     */
+    public static final int SYSTEMUI_SETTINGS_STANDARD_VOLUME_DEF = 0;
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_SETTINGS_STANDARD_BRIGHTNESS = "eos_systemui_settings_standard_brightness";
+    /**
+     * @hide
+     */
+    public static final int SYSTEMUI_SETTINGS_STANDARD_BRIGHTNESS_DEF = 1;
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_SETTINGS_STANDARD_NOTIFICATIONS = "eos_systemui_settings_standard_notifications";
+    /**
+     * @hide
+     */
+    public static final int SYSTEMUI_SETTINGS_STANDARD_NOTIFICATIONS_DEF = 1;
+    /**
+     * @hide
+     */
+    public static final String SYSTEMUI_SETTINGS_STANDARD_SETTINGS = "eos_systemui_settings_standard_settings";
+    /**
+     * @hide
+     */
+    public static final int SYSTEMUI_SETTINGS_STANDARD_SETTINGS_DEF = 1;
+    /**
+     * The touchpad gesture mode. (0 = spots, 1 = pointer)
+     * @hide
+     */
+    public static final String DEVICE_SETTINGS_TOUCHPAD_MODE = "eos_device_settings_touchpad_mode";
+    /**
+     * Whether or not the touchpad is enabled. (0 = false, 1 = true)
+     * @hide
+     */
+    public static final String DEVICE_SETTINGS_TOUCHPAD_STATUS = "eos_device_settings_touchpad_status";
+    /**
+     * Value for {@link #EOS_TOUCHPAD_STATUS} to use
+     * the touchpad located on the hardware keyboard dock.
+     * @hide
+     */
+    public static final int DEVICE_SETTINGS_TOUCHPAD_DISABLED = 0;
+    /**
+     * Value for {@link #EOS_TOUCHPAD_STATUS} to use
+     * the touchpad located on the hardware keyboard dock.
+     * @hide
+     */
+    public static final int DEVICE_SETTINGS_TOUCHPAD_ENABLED = 1;
+    /**
+     * On the grouper, we use this to switch between the hybrid UI and the tablet UI
+     * @hide
+     */
+    public static final String SYSTEMUI_USE_TABLET_UI = "eos_systemui_tablet_ui";
+    /**
+     * @hide
+     */
+    public static final int SYSTEMUI_USE_TABLET_UI_DEF = 0;
+}
diff --git a/core/res/res/values/config.xml b/core/res/res/values/config.xml
index ed5c3c1..f12ce4d 100755
--- a/core/res/res/values/config.xml
+++ b/core/res/res/values/config.xml
@@ -868,4 +868,7 @@
 
      <!-- Dock battery compatibility disabled by default -->
     <bool name="config_hasDockBattery">false</bool>
+
+    <!-- Touchpad compatibility disabled by default -->
+    <bool name="config_hasTouchpad">false</bool>
 </resources>
diff --git a/core/res/res/values/public.xml b/core/res/res/values/public.xml
index 47cf8fe..af81686 100644
--- a/core/res/res/values/public.xml
+++ b/core/res/res/values/public.xml
@@ -265,6 +265,8 @@
   <java-symbol type="bool" name="config_sendAudioBecomingNoisy" />
   <java-symbol type="bool" name="config_enableScreenshotChord" />
   <java-symbol type="bool" name="config_bluetooth_default_profiles" />
+  <java-symbol type="bool" name="config_hasDockBattery" />
+  <java-symbol type="bool" name="config_hasTouchpad" />
 
   <java-symbol type="integer" name="config_cursorWindowSize" />
   <java-symbol type="integer" name="config_longPressOnPowerBehavior" />
@@ -3656,6 +3658,4 @@
   <public type="style" name="Widget.Holo.Light.MediaRouteButton" id="0x010301d6" />
   <public type="style" name="Widget.DeviceDefault.MediaRouteButton" id="0x010301d7" />
   <public type="style" name="Widget.DeviceDefault.Light.MediaRouteButton" id="0x010301d8" />
-
-  <java-symbol type="bool" name="config_hasDockBattery" />
 </resources>
diff --git a/services/input/InputReader.cpp b/services/input/InputReader.cpp
index fe68e33..55d0fca 100644
--- a/services/input/InputReader.cpp
+++ b/services/input/InputReader.cpp
@@ -2710,6 +2710,15 @@ void TouchInputMapper::configure(nsecs_t when,
 
     mConfig = *config;
 
+    bool disableTouchpad = false;
+
+    // Find out if the touchpad is disabled.
+    if (mParameters.deviceType == Parameters::DEVICE_TYPE_POINTER) {
+        if (mConfig.touchpadStatus == 0) {
+            disableTouchpad = true;
+        }
+    }
+
     if (!changes) { // first time only
         // Configure basic parameters.
         configureParameters();
@@ -2742,11 +2751,45 @@ void TouchInputMapper::configure(nsecs_t when,
         configureSurface(when, &resetNeeded);
     }
 
+    if (mParameters.deviceType == Parameters::DEVICE_TYPE_POINTER) {
+        if (!changes || (changes & InputReaderConfiguration::CHANGE_TOUCHPAD_MODE)) {
+            // Change touchpad gesture
+            if (mConfig.touchpadMode == 0) {
+                mParameters.gestureMode = Parameters::GESTURE_MODE_SPOTS;
+            } else if (mConfig.touchpadMode == 1) {
+                mParameters.gestureMode = Parameters::GESTURE_MODE_POINTER;
+            } else {
+                ALOGW("Invalid value for touchpadMode: '%d'", mConfig.touchpadMode);
+            }
+            // Configure device sources, surface dimensions, orientation and
+            // scaling factors.
+            configureSurface(when, &resetNeeded);
+        }
+
+        if (!changes || (changes & InputReaderConfiguration::CHANGE_TOUCHPAD_STATUS)) {
+            // Change touchpad status.
+            if (mConfig.touchpadStatus == 0) {
+                disableTouchpad = true;
+            } else if (mConfig.touchpadStatus == 1) {
+                disableTouchpad = false;
+                // Configure device sources, surface dimensions, orientation and
+                // scaling factors.  This also conveniently re-enables the touchpad.
+                configureSurface(when, &resetNeeded);
+            } else {
+                ALOGW("Invalid value for touchpadStatus: '%d'", mConfig.touchpadStatus);
+            }
+        }
+    }
+
     if (changes && resetNeeded) {
         // Send reset, unless this is the first time the device has been configured,
         // in which case the reader will call reset itself after all mappers are ready.
         getDevice()->notifyReset(when);
     }
+    // disable the touchpad if required
+    if (disableTouchpad) {
+        mDeviceMode = DEVICE_MODE_DISABLED;
+    }
 }
 
 void TouchInputMapper::configureParameters() {
diff --git a/services/input/InputReader.h b/services/input/InputReader.h
index 122a2ab..5a73e2d 100644
--- a/services/input/InputReader.h
+++ b/services/input/InputReader.h
@@ -75,6 +75,12 @@ struct InputReaderConfiguration {
         // The device name alias supplied by the may have changed for some devices.
         CHANGE_DEVICE_ALIAS = 1 << 5,
 
+        // The touchpad gesture mode has changed.
+        CHANGE_TOUCHPAD_MODE = 1 << 6,
+
+        // The touchpad status has changed.
+        CHANGE_TOUCHPAD_STATUS = 1 << 7,
+
         // All devices must be reopened.
         CHANGE_MUST_REOPEN = 1 << 31,
     };
@@ -162,6 +168,12 @@ struct InputReaderConfiguration {
     // True to show the location of touches on the touch screen as spots.
     bool showTouches;
 
+    // The touchpad gesture mode.
+    int32_t touchpadMode;
+
+    // Touchpad status.
+    int32_t touchpadStatus;
+
     InputReaderConfiguration() :
             virtualKeyQuietTime(0),
             pointerVelocityControlParameters(1.0f, 500.0f, 3000.0f, 3.0f),
@@ -178,7 +190,9 @@ struct InputReaderConfiguration {
             pointerGestureSwipeMaxWidthRatio(0.25f),
             pointerGestureMovementSpeedRatio(0.8f),
             pointerGestureZoomSpeedRatio(0.3f),
-            showTouches(false) { }
+            showTouches(false),
+            touchpadMode(0),
+            touchpadStatus(1) { }
 
     bool getDisplayInfo(int32_t displayId, bool external,
             int32_t* width, int32_t* height, int32_t* orientation) const;
diff --git a/services/java/com/android/server/input/InputManagerService.java b/services/java/com/android/server/input/InputManagerService.java
index bdd0aa4..a2e4ea0 100644
--- a/services/java/com/android/server/input/InputManagerService.java
+++ b/services/java/com/android/server/input/InputManagerService.java
@@ -20,6 +20,7 @@ import com.android.internal.R;
 import com.android.internal.util.XmlUtils;
 import com.android.server.Watchdog;
 
+import org.teameos.jellybean.settings.EOSConstants;
 import org.xmlpull.v1.XmlPullParser;
 
 import android.Manifest;
@@ -135,6 +136,8 @@ public class InputManagerService extends IInputManager.Stub implements Watchdog.
             new HashMap<IBinder, VibratorToken>();
     private int mNextVibratorTokenValue;
 
+    private boolean mHasTouchpad = false;
+
     // State for the currently installed input filter.
     final Object mInputFilterLock = new Object();
     InputFilter mInputFilter; // guarded by mInputFilterLock
@@ -179,6 +182,8 @@ public class InputManagerService extends IInputManager.Stub implements Watchdog.
     private static native void nativeReloadDeviceAliases(int ptr);
     private static native String nativeDump(int ptr);
     private static native void nativeMonitor(int ptr);
+    private static native void nativeSetTouchpadMode(int ptr, int mode);
+    private static native void nativeSetTouchpadStatus(int ptr, int status);
 
     // Input event injection constants defined in InputDispatcher.h.
     private static final int INPUT_EVENT_INJECTION_SUCCEEDED = 0;
@@ -226,14 +231,25 @@ public class InputManagerService extends IInputManager.Stub implements Watchdog.
         Slog.i(TAG, "Starting input manager");
         nativeStart(mPtr);
 
+        mHasTouchpad = mContext.getResources().getBoolean(
+                com.android.internal.R.bool.config_hasTouchpad);
+
         // Add ourself to the Watchdog monitors.
         Watchdog.getInstance().addMonitor(this);
 
         registerPointerSpeedSettingObserver();
         registerShowTouchesSettingObserver();
+        if (mHasTouchpad) {
+            registerTouchpadModeSettingObserver();
+            registerTouchpadStatusSettingObserver();
+        }
 
         updatePointerSpeedFromSettings();
         updateShowTouchesFromSettings();
+        if (mHasTouchpad) {
+            updateTouchpadModeFromSettings();
+            updateTouchpadStatusFromSettings();
+        }
     }
 
     public void systemReady(BluetoothService bluetoothService) {
@@ -1071,6 +1087,18 @@ public class InputManagerService extends IInputManager.Stub implements Watchdog.
         nativeSetShowTouches(mPtr, setting != 0);
     }
 
+    public void updateTouchpadModeFromSettings()
+    {
+        int mode = getTouchpadModeSetting(0);
+        nativeSetTouchpadMode(mPtr, mode);
+    }
+
+    public void updateTouchpadStatusFromSettings()
+    {
+        int status = getTouchpadStatusSetting(1);
+        nativeSetTouchpadStatus(mPtr, status);
+    }
+
     private void registerShowTouchesSettingObserver() {
         mContext.getContentResolver().registerContentObserver(
                 Settings.System.getUriFor(Settings.System.SHOW_TOUCHES), true,
@@ -1082,6 +1110,28 @@ public class InputManagerService extends IInputManager.Stub implements Watchdog.
                 });
     }
 
+    private void registerTouchpadModeSettingObserver() {
+        mContext.getContentResolver().registerContentObserver(
+                Settings.System.getUriFor(EOSConstants.DEVICE_SETTINGS_TOUCHPAD_MODE), true,
+                new ContentObserver(mHandler) {
+                    @Override
+                    public void onChange(boolean selfChange) {
+                        updateTouchpadModeFromSettings();
+                    }
+                });
+    }
+
+    private void registerTouchpadStatusSettingObserver() {
+        mContext.getContentResolver().registerContentObserver(
+                Settings.System.getUriFor(EOSConstants.DEVICE_SETTINGS_TOUCHPAD_STATUS), true,
+                new ContentObserver(mHandler) {
+                    @Override
+                    public void onChange(boolean selfChange) {
+                        updateTouchpadStatusFromSettings();
+                    }
+                });
+    }
+
     private int getShowTouchesSetting(int defaultValue) {
         int result = defaultValue;
         try {
@@ -1092,6 +1142,26 @@ public class InputManagerService extends IInputManager.Stub implements Watchdog.
         return result;
     }
 
+    private int getTouchpadModeSetting(int defaultValue) {
+        int result = defaultValue;
+        try {
+            result = Settings.System.getInt(mContext.getContentResolver(),
+                    EOSConstants.DEVICE_SETTINGS_TOUCHPAD_MODE);
+        } catch (SettingNotFoundException snfe) {
+        }
+        return result;
+    }
+
+    private int getTouchpadStatusSetting(int defaultValue) {
+        int result = defaultValue;
+        try {
+            result = Settings.System.getInt(mContext.getContentResolver(),
+                    EOSConstants.DEVICE_SETTINGS_TOUCHPAD_STATUS);
+        } catch (SettingNotFoundException snfe) {
+        }
+        return result;
+    }
+
     // Binder call
     @Override
     public void vibrate(int deviceId, long[] pattern, int repeat, IBinder token) {
diff --git a/services/jni/com_android_server_input_InputManagerService.cpp b/services/jni/com_android_server_input_InputManagerService.cpp
index 0e1ce51..9894ce6 100644
--- a/services/jni/com_android_server_input_InputManagerService.cpp
+++ b/services/jni/com_android_server_input_InputManagerService.cpp
@@ -178,6 +178,8 @@ public:
     void setSystemUiVisibility(int32_t visibility);
     void setPointerSpeed(int32_t speed);
     void setShowTouches(bool enabled);
+    void setTouchpadMode(int32_t mode);
+    void setTouchpadStatus(int32_t status);
 
     /* --- InputReaderPolicyInterface implementation --- */
 
@@ -240,6 +242,12 @@ private:
         // Show touches feature enable/disable.
         bool showTouches;
 
+        // The touchpad gesture mode.
+        int32_t touchpadMode;
+
+        // Touchpad status.
+        int32_t touchpadStatus;
+
         // Sprite controller singleton, created on first use.
         sp<SpriteController> spriteController;
 
@@ -285,6 +293,8 @@ NativeInputManager::NativeInputManager(jobject contextObj,
         mLocked.pointerSpeed = 0;
         mLocked.pointerGesturesEnabled = true;
         mLocked.showTouches = false;
+        mLocked.touchpadMode = 0;
+        mLocked.touchpadStatus = 1;
     }
 
     sp<EventHub> eventHub = new EventHub();
@@ -448,6 +458,10 @@ void NativeInputManager::getReaderConfiguration(InputReaderConfiguration* outCon
 
         outConfig->showTouches = mLocked.showTouches;
 
+        outConfig->touchpadMode = mLocked.touchpadMode;
+
+        outConfig->touchpadStatus = mLocked.touchpadStatus;
+
         outConfig->setDisplayInfo(0, false /*external*/,
                 mLocked.displayWidth, mLocked.displayHeight, mLocked.displayOrientation);
         outConfig->setDisplayInfo(0, true /*external*/,
@@ -775,6 +789,38 @@ void NativeInputManager::setShowTouches(bool enabled) {
             InputReaderConfiguration::CHANGE_SHOW_TOUCHES);
 }
 
+void NativeInputManager::setTouchpadMode(int32_t mode) {
+    { // acquire lock
+        AutoMutex _l(mLock);
+
+        if (mLocked.touchpadMode == mode) {
+            return;
+        }
+
+        ALOGI("Setting touchpad mode to %d.", mode);
+        mLocked.touchpadMode = mode;
+    } // release lock
+
+    mInputManager->getReader()->requestRefreshConfiguration(
+            InputReaderConfiguration::CHANGE_TOUCHPAD_MODE);
+}
+
+void NativeInputManager::setTouchpadStatus(int32_t status) {
+    { // acquire lock
+        AutoMutex _l(mLock);
+
+        if (mLocked.touchpadStatus == status) {
+            return;
+        }
+
+        ALOGI("Setting touchpad status to %d.", status);
+        mLocked.touchpadStatus = status;
+    } // release lock
+
+    mInputManager->getReader()->requestRefreshConfiguration(
+            InputReaderConfiguration::CHANGE_TOUCHPAD_STATUS);
+}
+
 bool NativeInputManager::isScreenOn() {
     return android_server_PowerManagerService_isScreenOn();
 }
@@ -1324,6 +1370,20 @@ static void nativeMonitor(JNIEnv* env, jclass clazz, jint ptr) {
     im->getInputManager()->getDispatcher()->monitor();
 }
 
+static void nativeSetTouchpadMode(JNIEnv* env,
+        jclass clazz, jint ptr, jint mode) {
+    NativeInputManager* im = reinterpret_cast<NativeInputManager*>(ptr);
+
+    im->setTouchpadMode(mode);
+}
+
+static void android_server_InputManager_nativeSetTouchpadStatus(JNIEnv* env,
+        jclass clazz, jint ptr, jint status) {
+    NativeInputManager* im = reinterpret_cast<NativeInputManager*>(ptr);
+
+    im->setTouchpadStatus(status);
+}
+
 // ----------------------------------------------------------------------------
 
 static JNINativeMethod gInputManagerMethods[] = {
@@ -1380,6 +1440,10 @@ static JNINativeMethod gInputManagerMethods[] = {
             (void*) nativeDump },
     { "nativeMonitor", "(I)V",
             (void*) nativeMonitor },
+    { "nativeSetTouchpadMode", "(II)V",
+            (void*) nativeSetTouchpadMode },
+    { "nativeSetTouchpadStatus", "(II)V",
+            (void*) android_server_InputManager_nativeSetTouchpadStatus },
 };
 
 #define FIND_CLASS(var, className) \
